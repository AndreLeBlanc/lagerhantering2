#ifndef BST_H
#define BST_H

#include <stdbool.h>

/**************/
/*   PUBLIC   */
/**************/

/** An element in the set.
 *  An element of type \ref struct element_t.
 *  \note Elements are automatically created with data when using \ref insert_element.
 *  \note You may access existing element's data using \ref search and \ref iter_getdata.
 *  \sa insert_element
 *  \sa search
 *  \sa iter_getdata
 */
typedef struct element_t element_t;

/** A set.
 *  A set of type \ref struct set_t.
 *  Constructor: \ref new_set.
 *  Destructor:  \ref free_set.
 *  \sa new_set
 *  \sa free_set
 */
typedef struct set_t set_t;

/** An iterator for a set.
 *  Iterates a set using various function.
 *  Use this for looping a subset of a set, for manipulating the entire
 *  set instead use \ref set_foreachdata
 *  Constructor: \ref iter_new
 *  Destructor:  \ref iter_free
 *  
 *  \sa iter_start
 *  \sa iter_end
 *  \sa iter_nsteps
 *  \sa iter_toindex
 *  \sa iter_getdata
 *  \sa iter_index
 *  \sa set_foreachdata
 */
typedef struct iter_t iter_t;

/** A key comparator.
 * A comparator for they keys generated by a complementing \ref key_generator_t.
 * \param key1 A key.
 * \param key2 A key.
 * \returns 0 if key1 == key2, <0 if key1 < key2, and >0 if key1>key2.
 * \sa key_generator_t
 */
typedef int key_comparator_t (void* key1, void* key2);

/** A key generator.
 * Generates a key based on user provided data.
 * \param data The data.
 * \returns The key.
 */
typedef void* key_generator_t (void* data);

/** A function that frees a key.
 * Frees a key generated by a complementing \ref key_generator_t.
 * \param key The key.
 */
typedef void key_freer_t (void* key);

/** Allocates memory for a copy of data.
 * Allocates new memory for a copy of data.
 * \param data Data to copy.
 * \returns Copied data.
 */
typedef void* data_copier_t (void* data);

/** Frees user provided data.
 * Frees user provided data.
 * \param data The data.
 */
typedef void data_freer_t (void* data);

/** Function to map over data.
 * A function use on any found data. Use in functions that
 * that a predicate as argument.
 * \param data The data.
 * \sa set_foreachdata
 */
typedef void data_map_fun_t (void* data);

/** Set constructor.
 * Creates an empty set.
 * \param key_gen The \ref key_generator_t to generate keys with.
 * \param key_comp The \ref key_comparator_t to compare two keys with.
 * \param key_freer The \ref key_freer_t to free a key with.
 * \param data_copier The \ref data_copier_t to copy data with.
 * \param data_freer The \ref data_freer_t to free an elements data with.
 * \returns A pointer to an empty set.
 * \warning If provided functions are incompatible program may crash.
 * \sa free_set
 */
set_t* new_set (key_generator_t* key_gen, key_comparator_t* key_comp, key_freer_t* key_freer, data_copier_t* data_copier, data_freer_t* data_freer);

/** Get copy of a set
 * with all data copied.
 * \param set The set
 * \returns A copy of the set if valid, otherwise null ptr.
 */

set_t* copy_set (set_t* set);

/** Set destructor.
 * Free the memory allocated by the set, its elements and their data.
 * \params set The set to free.
 */
void free_set (set_t* set);

/** Checks if a set is empty.
 * Checks if a set is empty.
 * \param set The set to check.
 * \returns false if the set contains one or more elements,
 * true otherwise.
 */
bool set_is_empty (set_t* set);

/** Searches for data.
 * Search for and access data with a key.
 * \params set The set to search in.
 * \params key Key of element with sought data.
 * \returns A pointer to a data pointer if one was matched,
 * otherwise a null pointer.
 * \invariant key != NULL
 */
void* searchdata (set_t* set, void* key);

/** Get element count of set.
 * Get element count of set.
 * \param set The set.
 * \return A number representing the count.
 */
int set_getcount (set_t* set);

/** Inserts an element.
 * Insert a new element into set. Automatically allocates
 * space for the element and its data.
 * \param set The set to insert into.
 * \param data The data of the new element.
 * \warning Successful inserts cause associated iterators
 * to reset using \ref iter_reset.
 * \sa iter_reset
 * \sa delete_element
 * \sa new_set
 */
void insert_element(set_t* set, void* data);

/** Deletes an element. // todo remove based on key
 * Deletes element based on supplied key.
 * If the element is not found nothing is deleted.
 * \params set The set to delete from.
 * \params key Key to base search on. Supplied \ref key_generator_t should be used to generate key.
 * \warning Successful inserts cause associated iterators
 * to reset using \ref iter_reset.
 * \sa iter_reset
 * \sa key_generator_t
 */
void delete_element(set_t* set, void* key);

/** Iterates and applies predicate to set.
 * Iterate over a set in order.
 * Map the function over the data of each element in the set.
 * \params set The set to iterate through.
 * \params fun The \key data_map_fun_t function to map on each data.
 */
void set_foreachdata (set_t* set, data_map_fun_t fun);

/** Iterator constructor.
 * Create an iterator to a list. Needs to be freed using \ref
 * iter_free.
 * \params set The set to connect the iterator to.
 * \sa http://en.wikipedia.org/wiki/Iterator
 * \sa iter_free
 */
iter_t* iter_new(set_t* set);

/** Iterator destructor.
 * Free the memory allocated by the iterator.
 * \param iter The iterator.
 * \sa iter_new
 */
void iter_free(iter_t* iter);

/** Step iterator forwards n steps.
 * Iterate n steps forwards within existing range of a set.
 * \param iter The iterator.
 * \param n Number of steps. No iteration if n < 1,
 * advances iterator by n steps, n > 0.
 * \note iterating 1 step substitutes a separate iterate function
 * \warn Iteration only occurs withing available range.
 * \sa iter_start
 * \sa iter_end
 * \sa set_is_empty
 */
void iter_nsteps(iter_t* iter, int n);

/** Step iterator to index.
 * Steps appropriately to get to an index.
 * \param iter The iterator to step.
 * \param i The index to step to.
 * \note Same invariants \ref iter_nsteps applies.
 * \sa iter_nsteps 
 */
void iter_toindex(iter_t* iter, int i); // todo remove once alt. way to browse is done

/** Check if at end.
 * Test whether the iterator has additional elements after current position.
 * \param iter The iterator.
 * \returns `true` if the iterator has additional elements,
 * `false` otherwise.
 */
bool iter_end(iter_t* iter);

/** Check if at beginning.
 * Test whether the iterator has preceding elements after current position.
 * \param iter The iterator.
 * \returns `true` if the iterator has preceding elements,
 * `false` otherwise.
 */
bool iter_start(iter_t* iter);

/** Access data of the current element.
 * Access data of the current element of an iterator.
 * \param The iterator.
 * \returns The current data.
 * \invariant !set_is_empty(iter_t->set)
 * \sa set_is_empty
 */
void* iter_getdata(iter_t* iter);

/** Reset iterator position.
 * Sets the set's first element as the current element of the iterator.
 * \param iter The iterator.
 */
void iter_reset(iter_t* iter);

/** Get iterator index.
 * Get the current index of the iterator.
 * \param iter The iterator.
 * \returns The current index.
 * \warning proper index only promised if associated set not empty.
 * \sa set_is_empty
 */
int iter_index(iter_t* iter); // todo remove once alt. way to browse is done
#endif //BST_H
